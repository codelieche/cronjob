# Runner设计文档

## 概述

Runner是Worker中负责具体任务执行的核心组件。系统根据`Task.Category`字段来选择不同的Runner来执行不同类型的任务。Runner采用插件化架构，支持动态扩展和自定义实现。

## 设计原则

1. **统一接口**: 所有Runner都实现相同的接口，便于管理和扩展
2. **参数解析**: 支持从Task.Command和Task.Args中解析Runner所需的参数
3. **生命周期管理**: 支持启动、停止、超时、取消等完整的生命周期管理
4. **结果上报**: 统一的执行结果格式和上报机制
5. **错误处理**: 完善的错误处理和异常恢复机制
6. **资源管理**: 合理的资源使用和清理机制

## 核心接口

### Runner接口定义

```go
// Runner 任务执行器接口
type Runner interface {
    // 参数解析和初始化
    ParseArgs(command string, args string) error
    
    // 任务执行
    Execute(ctx context.Context) (*Result, error)
    
    // 任务停止
    Stop() error
    
    // 任务强制终止
    Kill() error
    
    // 获取执行状态
    GetStatus() Status
    
    // 获取执行结果
    GetResult() *Result
    
    // 设置超时
    SetTimeout(timeout time.Duration)
    
    // 清理资源
    Cleanup() error
}
```

### 执行结果结构

```go
// Result 任务执行结果
type Result struct {
    Status    string    `json:"status"`     // 执行状态
    Output    string    `json:"output"`     // 执行输出
    Error     string    `json:"error"`      // 错误信息
    StartTime time.Time `json:"start_time"` // 开始时间
    EndTime   time.Time `json:"end_time"`   // 结束时间
    Duration  int64     `json:"duration"`   // 执行时长(毫秒)
    ExitCode  int       `json:"exit_code"`  // 退出码
}
```

### 执行状态枚举

```go
// Status 执行状态
type Status string

const (
    StatusPending   Status = "pending"   // 等待执行
    StatusRunning   Status = "running"   // 正在执行
    StatusSuccess   Status = "success"   // 执行成功
    StatusFailed    Status = "failed"    // 执行失败
    StatusTimeout   Status = "timeout"   // 执行超时
    StatusCanceled  Status = "canceled"  // 已取消
    StatusError     Status = "error"     // 执行错误
)
```

## Runner实现规范

### 1. 参数解析

每个Runner都需要实现`ParseArgs`方法来解析任务参数：

```go
func (r *CommandRunner) ParseArgs(command string, args string) error {
    // 解析command作为可执行文件路径
    r.command = command
    
    // 解析args作为JSON格式的参数数组
    var argList []string
    if err := json.Unmarshal([]byte(args), &argList); err != nil {
        return fmt.Errorf("解析参数失败: %w", err)
    }
    r.args = argList
    
    return nil
}
```

### 2. 任务执行

实现`Execute`方法执行具体任务：

```go
func (r *CommandRunner) Execute(ctx context.Context) (*Result, error) {
    // 设置状态为运行中
    r.status = StatusRunning
    r.startTime = time.Now()
    
    // 创建执行命令
    cmd := exec.CommandContext(ctx, r.command, r.args...)
    
    // 设置输出捕获
    var stdout, stderr bytes.Buffer
    cmd.Stdout = &stdout
    cmd.Stderr = &stderr
    
    // 执行命令
    err := cmd.Run()
    
    // 构建结果
    result := &Result{
        Status:    r.status,
        StartTime: r.startTime,
        EndTime:   time.Now(),
        Duration:  time.Since(r.startTime).Milliseconds(),
        Output:    stdout.String(),
        ExitCode:  cmd.ProcessState.ExitCode(),
    }
    
    if err != nil {
        result.Status = StatusFailed
        result.Error = err.Error()
    } else {
        result.Status = StatusSuccess
    }
    
    return result, nil
}
```

### 3. 超时处理

支持任务超时控制：

```go
func (r *CommandRunner) SetTimeout(timeout time.Duration) {
    r.timeout = timeout
}

func (r *CommandRunner) Execute(ctx context.Context) (*Result, error) {
    // 创建带超时的上下文
    if r.timeout > 0 {
        var cancel context.CancelFunc
        ctx, cancel = context.WithTimeout(ctx, r.timeout)
        defer cancel()
    }
    
    // 执行任务...
}
```

### 4. 任务停止和终止

支持优雅停止和强制终止：

```go
func (r *CommandRunner) Stop() error {
    if r.cmd != nil && r.cmd.Process != nil {
        // 发送SIGTERM信号
        return r.cmd.Process.Signal(syscall.SIGTERM)
    }
    return nil
}

func (r *CommandRunner) Kill() error {
    if r.cmd != nil && r.cmd.Process != nil {
        // 发送SIGKILL信号
        return r.cmd.Process.Signal(syscall.SIGKILL)
    }
    return nil
}
```

## 内置Runner类型

### 1. CommandRunner

**用途**: 执行系统命令和脚本

**参数格式**:
```json
{
  "command": "/bin/ls",
  "args": "[\"-la\", \"/tmp\"]"
}
```

**特性**:
- 支持任意系统命令执行
- 支持参数传递
- 支持输出捕获
- 支持超时控制
- 支持信号处理

### 2. ScriptRunner (计划中)

**用途**: 执行各种脚本文件

**参数格式**:
```json
{
  "script_path": "/path/to/script.sh",
  "interpreter": "bash",
  "args": "[\"arg1\", \"arg2\"]"
}
```

### 3. DockerRunner (计划中)

**用途**: 在Docker容器中执行任务

**参数格式**:
```json
{
  "image": "ubuntu:20.04",
  "command": "ls",
  "args": "[\"-la\"]",
  "volumes": ["/host/path:/container/path"],
  "env": {"KEY": "value"}
}
```

### 4. HttpRunner (计划中)

**用途**: 执行HTTP请求

**参数格式**:
```json
{
  "url": "https://api.example.com/webhook",
  "method": "POST",
  "headers": {"Content-Type": "application/json"},
  "body": "{\"message\": \"hello\"}"
}
```

## Runner注册机制

### 1. 注册表

```go
// RunnerRegistry Runner注册表
type RunnerRegistry struct {
    runners map[string]RunnerFactory
    mutex   sync.RWMutex
}

// RunnerFactory Runner工厂函数
type RunnerFactory func() Runner

// Register 注册Runner
func (r *RunnerRegistry) Register(category string, factory RunnerFactory)

// Create 创建Runner实例
func (r *RunnerRegistry) Create(category string) (Runner, error)
```

### 2. 自动注册

```go
func init() {
    registry.Register("command", func() Runner {
        return &CommandRunner{}
    })
    
    registry.Register("script", func() Runner {
        return &ScriptRunner{}
    })
    
    registry.Register("docker", func() Runner {
        return &DockerRunner{}
    })
}
```

## 错误处理

### 1. 错误分类

- **参数错误**: 参数解析失败
- **执行错误**: 任务执行过程中出错
- **超时错误**: 任务执行超时
- **系统错误**: 系统资源不足等
- **网络错误**: 网络连接问题

### 2. 错误恢复

- 自动重试机制
- 降级处理
- 错误日志记录
- 告警通知

## 性能优化

### 1. 资源管理

- 进程池管理
- 内存使用控制
- 文件描述符限制
- 并发控制

### 2. 执行优化

- 异步执行
- 批量处理
- 结果缓存
- 输出流式处理

## 监控和日志

### 1. 执行监控

- 执行时间统计
- 成功率监控
- 资源使用监控
- 错误率统计

### 2. 日志记录

- 执行开始/结束日志
- 错误详情日志
- 性能指标日志
- 调试信息日志

## 扩展指南

### 1. 实现自定义Runner

```go
// 1. 实现Runner接口
type CustomRunner struct {
    // 自定义字段
}

func (r *CustomRunner) ParseArgs(command string, args string) error {
    // 实现参数解析
}

func (r *CustomRunner) Execute(ctx context.Context) (*Result, error) {
    // 实现任务执行
}

// 2. 注册Runner
func init() {
    registry.Register("custom", func() Runner {
        return &CustomRunner{}
    })
}
```

### 2. 配置Runner

```go
// 通过配置文件或环境变量配置Runner参数
type RunnerConfig struct {
    MaxConcurrency int           `json:"max_concurrency"`
    DefaultTimeout time.Duration `json:"default_timeout"`
    ResourceLimits ResourceLimits `json:"resource_limits"`
}
```

## 测试策略

### 1. 单元测试

- 参数解析测试
- 执行逻辑测试
- 错误处理测试
- 超时处理测试

### 2. 集成测试

- 端到端执行测试
- 多Runner并发测试
- 资源清理测试
- 异常恢复测试

### 3. 性能测试

- 并发执行测试
- 内存使用测试
- 执行时间测试
- 资源限制测试
