# CommandRunner 安全配置指南

## 概述

CommandRunner 内置了强大的安全控制机制，可以防止执行危险的系统命令，保护系统安全。

## 安全特性

### 1. 多层安全检查
- **命令黑名单**: 禁止执行特定的危险命令
- **模式匹配**: 使用正则表达式检测危险命令模式
- **路径保护**: 防止访问系统关键路径
- **参数长度限制**: 防止过长的命令参数

### 2. 配置方式
- **环境变量**: 通过环境变量动态配置
- **默认配置**: 内置安全的默认配置
- **运行时检查**: 在命令解析时进行安全检查

## 默认安全规则

### 禁止的命令
```json
[
  "rm", "del", "rd", "rmdir", "format", "fdisk", "mkfs",
  "dd", "shutdown", "reboot", "halt", "poweroff",
  "init", "systemctl", "service", "chmod", "chown",
  "sudo", "su", "passwd", "useradd", "userdel",
  "mount", "umount", "fdisk", "parted"
]
```

### 禁止的模式
```json
[
  "rm\\s+.*-rf.*/",           // rm -rf /
  "rm\\s+.*-rf.*\\*",         // rm -rf *
  "rm\\s+.*-rf.*\\.\\.",      // rm -rf ..
  "del\\s+.*/s.*/q.*\\*",     // del /s /q *
  "format\\s+.*c:",           // format c:
  "shutdown\\s+.*-h\\s+now",  // shutdown -h now
  "reboot\\s+.*-f",           // reboot -f
  "dd\\s+.*if=.*of=.*",       // dd if=/dev/zero of=...
  "chmod\\s+.*777",           // chmod 777
  "chown\\s+.*root",          // chown root
  "sudo\\s+.*",               // sudo.*
  "su\\s+.*",                 // su.*
  "passwd\\s+.*",             // passwd.*
  "useradd\\s+.*",            // useradd.*
  "userdel\\s+.*"             // userdel.*
]
```

### 禁止的路径
```json
[
  "/", "/bin", "/sbin", "/usr", "/etc", "/var", "/root",
  "C:\\\\", "C:\\\\Windows", "C:\\\\System32"
]
```

## 环境变量配置

### 禁用安全检查
```bash
export COMMAND_SECURITY_DISABLED=true
```

### 自定义允许的命令
```bash
export COMMAND_ALLOWED="echo,ls,ping,date,whoami,pwd"
```

### 自定义禁止的命令
```bash
export COMMAND_BLOCKED="rm,del,format,shutdown,reboot"
```

### 自定义禁止的模式
```bash
export COMMAND_BLOCKED_PATTERNS="rm\\s+.*-rf.*/,del\\s+.*/s.*/q.*\\*"
```

### 自定义禁止的路径
```bash
export COMMAND_BLOCKED_PATHS="/,/bin,/sbin,/usr,/etc,/var,/root"
```

## 使用示例

### 1. 基本使用
```go
runner := runner.NewCommandRunner()

// 安全命令 - 允许执行
err := runner.ParseArgs("echo Hello World", "")
if err != nil {
    fmt.Printf("被阻止: %v\n", err)
}

// 危险命令 - 被阻止
err = runner.ParseArgs("rm -rf /", "")
if err != nil {
    fmt.Printf("被阻止: %v\n", err) // 输出: 被阻止: 安全检查失败: 命令 'rm' 被禁止执行
}
```

### 2. 任务服务中的使用
```go
task := &core.Task{
    ID:       uuid.New(),
    Name:     "safe-task",
    Category: "command",
    Command:  "ping 8.8.8.8 -c 3", // 安全命令
    Args:     "",
    Timeout:  30,
}

taskService.ExecuteTask(task) // 正常执行
```

### 3. 危险任务示例
```go
task := &core.Task{
    ID:       uuid.New(),
    Name:     "dangerous-task",
    Category: "command",
    Command:  "rm -rf /", // 危险命令
    Args:     "",
    Timeout:  30,
}

taskService.ExecuteTask(task) // 被安全机制阻止
```

## 安全建议

### 1. 生产环境配置
- 始终启用安全检查
- 根据实际需求调整安全规则
- 定期审查和更新安全配置
- 监控被阻止的命令执行尝试

### 2. 开发环境配置
- 可以临时禁用安全检查进行测试
- 使用白名单模式限制可执行的命令
- 记录所有安全事件

### 3. 自定义安全规则
- 根据业务需求添加特定的禁止模式
- 考虑添加文件大小限制
- 实现命令执行时间限制
- 添加用户权限检查

## 故障排除

### 1. 命令被意外阻止
检查命令是否匹配以下条件：
- 命令名在黑名单中
- 命令模式匹配禁止的模式
- 命令包含禁止的路径
- 命令参数过长

### 2. 允许特定命令
使用环境变量添加允许的命令：
```bash
export COMMAND_ALLOWED="ls,ping,echo,date,whoami,pwd"
```

### 3. 临时禁用安全检查
```bash
export COMMAND_SECURITY_DISABLED=true
```

## 监控和日志

### 1. 安全事件日志
所有被阻止的命令都会记录详细的错误信息，包括：
- 被阻止的原因
- 命令内容
- 匹配的规则
- 时间戳

### 2. 监控指标
建议监控以下指标：
- 被阻止的命令数量
- 被阻止的命令类型分布
- 安全规则匹配频率
- 异常命令执行尝试

## 最佳实践

1. **最小权限原则**: 只允许必要的命令
2. **定期审查**: 定期检查和更新安全规则
3. **分层防护**: 结合其他安全机制
4. **监控告警**: 设置安全事件告警
5. **文档记录**: 详细记录安全配置和变更

通过合理配置 CommandRunner 的安全机制，可以有效防止危险命令的执行，保护系统安全。
